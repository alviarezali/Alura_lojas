# -*- coding: utf-8 -*-
"""AluraStoreBr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16h0DiXhw1F-p3Iswyn6oou-Ay4TDnAim

### Importação dos dados
"""

import pandas as pd

url = "https://raw.githubusercontent.com/alura-es-cursos/challenge1-data-science/refs/heads/main/base-de-dados-challenge-1/loja_1.csv"
url2 = "https://raw.githubusercontent.com/alura-es-cursos/challenge1-data-science/refs/heads/main/base-de-dados-challenge-1/loja_2.csv"
url3 = "https://raw.githubusercontent.com/alura-es-cursos/challenge1-data-science/refs/heads/main/base-de-dados-challenge-1/loja_3.csv"
url4 = "https://raw.githubusercontent.com/alura-es-cursos/challenge1-data-science/refs/heads/main/base-de-dados-challenge-1/loja_4.csv"

loja = pd.read_csv(url)
loja2 = pd.read_csv(url2)
loja3 = pd.read_csv(url3)
loja4 = pd.read_csv(url4)

loja.head()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from math import *
import statistics
from scipy.stats import mode

loja.describe()

# Resumo estatístico com nulos e tipos de dados (Loja)
resumen1 = loja.describe(include='all').T
resumen1['nulos'] = loja.isnull().sum()
resumen1['tipo_dato'] = loja.dtypes
print(resumen1)

# Resumo estatístico com nulos e tipos de dados (Loja2)
resumen2 = loja2.describe(include='all').T
resumen2['nulos'] = loja2.isnull().sum()
resumen2['tipo_dato'] = loja2.dtypes
print(resumen2)

# Resumo estatístico com nulos e tipos de dados (Loja3)
resumen3 = loja3.describe(include='all').T
resumen3['nulos'] = loja3.isnull().sum()
resumen3['tipo_dato'] = loja3.dtypes
print(resumen3)

# Resumo estatístico com nulos e tipos de dados (Loja4)
resumen4 = loja4.describe(include='all').T
resumen4['nulos'] = loja4.isnull().sum()
resumen4['tipo_dato'] = loja4.dtypes
print(resumen4)

"""#1. Análise do faturamento

"""

#Lista de DataFrames das lojas para análise
lojas = [loja, loja2, loja3, loja4]

# Cria figura com 4 subplots (2x2) e define tamanho
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(10, 8))
axes = axes.flatten()  # Transforma a matriz 2x2 em array 1D para facilitar iteração

# Plota histogramas de preços para cada loja
for i in range(len(lojas)):
    axes[i].hist(lojas[i]["Preço"], bins=20)  # Histograma com 20 intervalos
    axes[i].set_title(f"Loja {i+1} - Faturamento")  # Título dinâmico
    axes[i].grid(True)  # Adiciona grid para melhor visualização

# Configura 4 gráficos (boxplot) em 2 linhas e 2 colunas
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(10, 8))
axes = axes.flatten()  # Transforma em array 1D para iteração

# Gera boxplot do preço para cada loja
for i in range(len(lojas)):
    axes[i].boxplot(lojas[i]["Preço"])  # Análise de distribuição e outliers
    axes[i].set_title(f"Loja {i+1} - Faturamento")  # Título com numeração automática
    axes[i].grid(True)  # Grid para melhor referência visual

# Calcula o faturamento total de cada loja e armazena em um dicionário
quant_faturamento = {}
for i in range(len(lojas)):
    soma = sum(lojas[i]["Preço"])  # Soma todos os valores da coluna "Preço"
    if i == 0:
        quant_faturamento["loja"] = soma  # Nome simples para a primeira loja
    else:
        quant_faturamento[f"loja{i}"] = soma  # Demais lojas com numeração

# Configura o gráfico de barras
plt.figure(figsize=(8, 5))
bars = plt.bar(quant_faturamento.keys(), quant_faturamento.values(),
              color=['blue', 'green', 'red', 'purple'])  # Cores diferenciadas

# Ajusta escala do eixo Y (com margem de 0.2% abaixo e 1% acima)
min_val = min(quant_faturamento.values())
max_val = max(quant_faturamento.values())
plt.ylim(min_val * 0.998, max_val * 1.01)

# Adiciona valores monetários no topo de cada barra
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, height, f"R$ {height:,.2f}",
            ha='center', va='bottom', fontsize=10)

# Formatação final do gráfico
plt.title("Faturamento por Loja (Escala Ajustada)")
plt.ylabel("Faturamento Total")
plt.grid(axis='y', linestyle='--', alpha=0.7)  # Grid horizontal sutil
plt.show()

# Converte os valores de faturamento em inteiros para o gráfico de pizza
percentagem = [int(valor) for valor in quant_faturamento.values()]

# Cria e configura o gráfico de pizza
fig, ax = plt.subplots()
ax.pie(
    percentagem,
    labels=("Loja", "Loja2", "Loja3", "Loja4"),  # Rótulos das fatias
    autopct='%1.1f%%',  # Mostra porcentagens com 1 casa decimal
    shadow=True,       # Adiciona efeito de sombra
    explode=(0.1, 0, 0, 0)  # Destaca a primeira fatia
)
plt.title("Distribuição Percentual por Loja")
plt.show()

"""# 2. Vendas por Categoria

"""

# Configura 4 gráficos de faturamento por categoria (2x2)
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 9))
axes = axes.flatten()  # Converte para array 1D

for i in range(len(lojas)):
    # Agrupa dados por categoria e soma os preços
    grouped_data = lojas[i].groupby("Categoria do Produto").sum()["Preço"]

    # Cria barras com cores uniformes
    bars = axes[i].bar(grouped_data.index, grouped_data.values, color='skyblue')

    # Adiciona valores formatados no topo de cada barra
    for bar in bars:
        height = bar.get_height()
        axes[i].text(bar.get_x() + bar.get_width()/2, height,
                   f'R$ {height:,.2f}',
                   ha='center', va='bottom',
                   fontsize=8)

    # Configurações de eixo e estilo
    axes[i].set_title(f"Loja {i+1} - Faturamento por Categoria")  # Corrigido para i+1
    axes[i].set_xlabel("Categoria")
    axes[i].set_ylabel("Total Faturado (R$)")
    axes[i].tick_params(axis='x', rotation=80)  # Rotação para melhor legibilidade
    axes[i].grid(axis='y', linestyle='--', alpha=0.7)

# Ajusta layout para evitar sobreposição
plt.tight_layout()
plt.show()

"""# 3. Média de Avaliação das Lojas"""

# Calcula média, moda e desvio padrão das avaliações para cada loja
medias = {
    ("Loja" if i == 0 else f"Loja{i}"): (
        statistics.mean(lojas[i]["Avaliação da compra"]),
        statistics.mode(lojas[i]["Avaliação da compra"]),
        statistics.stdev(lojas[i]["Avaliação da compra"])
    )
    for i in range(len(lojas))
}

# Ordena lojas pela média (maior para menor)
medias_order = dict(sorted(medias.items(), key=lambda item: item[1][0], reverse=True))

# Prepara dados para plotagem
values = np.array(list(medias_order.values()))
variables = list(medias_order.keys())
categorias = ['Média', 'Moda', 'Desvio Padrão']

# Configura gráfico de barras agrupadas
fig, ax = plt.subplots(figsize=(12, 6))
x = np.arange(len(variables))
ancho = 0.25  # Largura das barras

# Plota cada métrica como grupo de barras
for i in range(3):
    ax.bar(x + i * ancho, values[:, i], width=ancho, label=categorias[i])

# Formatação do gráfico
ax.set_xticks(x + ancho)
ax.set_xticklabels(variables)
ax.set_title('Comparação Estatística por Loja (Ordenado por Média)')
ax.set_ylabel('Valor')
ax.legend(loc='upper right')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""# 4. Produtos Mais e Menos Vendidos"""

# Dicionário para armazenar produtos extremos (maior/menor preço) por loja
produtos_extremos = {}

for i in range(len(lojas)):
    # Agrupa produtos e soma seus preços
    serie_precos = lojas[i].groupby("Produto").sum()["Preço"]

    # Define nome da loja (formato especial para primeira loja)
    nome_loja = "Loja" if i == 0 else f"Loja{i}"

    if not serie_precos.empty:
        # Encontra produto mais caro
        produto_max = serie_precos.idxmax()  # Nome do produto
        preco_max = serie_precos.max()      # Valor máximo

        # Encontra produto mais barato
        produto_min = serie_precos.idxmin()  # Nome do produto
        preco_min = serie_precos.min()      # Valor mínimo

        # Armazena resultados
        produtos_extremos[nome_loja] = {
            "Máximo": (produto_max, preco_max),
            "Mínimo": (produto_min, preco_min)
        }
    else:
        # Caso não haja dados
        produtos_extremos[nome_loja] = {
            "Máximo": (None, None),
            "Mínimo": (None, None)
        }

# Converte para DataFrame para melhor visualização
df_extremos = pd.DataFrame(produtos_extremos).T
df_extremos

# ======================
# ANÁLISE DE PREÇOS EXTREMOS
# ======================

# 1. Processamento dos dados (identificação de máximos e mínimos)
produtos_extremos = {}

for i, loja in enumerate(lojas, 1):
    # Agrupa e soma preços por produto
    precos_agrupados = loja.groupby("Produto")["Preço"].sum()

    # Define nome da loja (formato especial para primeira loja)
    nome_loja = "Loja" if i == 1 else f"Loja{i}"

    # Extrai produtos com preços extremos
    produtos_extremos[nome_loja] = {
        "Máximo": (precos_agrupados.idxmax(), precos_agrupados.max()) if not precos_agrupados.empty else (None, None),
        "Mínimo": (precos_agrupados.idxmin(), precos_agrupados.min()) if not precos_agrupados.empty else (None, None)
    }

# Converte para DataFrame e expande as tuplas
df_extremos = pd.DataFrame(produtos_extremos).T
df_extremos = df_extremos.applymap(lambda x: (None, None) if pd.isna(x[0]) else x)
df_extremos[['Produto Máximo', 'Preço Máximo']] = df_extremos['Máximo'].apply(pd.Series)
df_extremos[['Produto Mínimo', 'Preço Mínimo']] = df_extremos['Mínimo'].apply(pd.Series)

# 2. Visualização avançada
plt.figure(figsize=(14, 8))
cores = {'Máximos': '#2ca02c', 'Mínimos': '#d62728'}  # Paleta acessível

# Configuração das barras
bar_width = 0.35
x = np.arange(len(df_extremos))
maximos = df_extremos['Preço Máximo'].fillna(0)
minimos = df_extremos['Preço Mínimo'].fillna(0)

# Plotagem com tratamento de valores nulos
bars_max = plt.bar(x - bar_width/2, maximos, bar_width,
                  color=cores['Máximos'], label='Máximos', alpha=0.85)
bars_min = plt.bar(x + bar_width/2, minimos, bar_width,
                  color=cores['Mínimos'], label='Mínimos', alpha=0.85)

# Função para anotações inteligentes
def annotate_bars(bars, produtos, is_max=True):
    for bar, produto, valor in zip(bars, produtos, [bar.get_height() for bar in bars]):
        if valor > 0:  # Ignora valores nulos
            offset = 30 if is_max else -40
            va = 'bottom' if is_max else 'top'
            plt.annotate(
                f"{produto[:15]}...\nR$ {valor:,.2f}" if len(str(produto)) > 15 else f"{produto}\nR$ {valor:,.2f}",
                xy=(bar.get_x() + bar.get_width()/2, bar.get_height()),
                xytext=(0, offset),
                textcoords="offset points",
                ha='center',
                va=va,
                fontsize=9,
                bbox=dict(boxstyle="round,pad=0.3", facecolor='white', edgecolor='gray', alpha=0.8)
            )

# Aplicando anotações
annotate_bars(bars_max, df_extremos['Produto Máximo'], is_max=True)
annotate_bars(bars_min, df_extremos['Produto Mínimo'], is_max=False)

# Configurações finais do gráfico
plt.title('Distribuição de Preços Extremos por Loja', fontsize=14, pad=20)
plt.xlabel('Lojas', fontsize=12)
plt.ylabel('Valor (R$ - Escala Log)', fontsize=12)
plt.xticks(x, df_extremos.index, rotation=45, ha='right')
plt.yscale('log')  # Escala logarítmica para melhor visualização
plt.grid(axis='y', linestyle=':', alpha=0.6)
plt.legend(title='Legenda:')
plt.tight_layout()

plt.show()

"""# 5. Frete Médio por Loja

"""

# =====================================
# ANÁLISE COMPARATIVA DE CUSTOS DE FRETE
# =====================================

# 1. Cálculo das métricas de frete (forma otimizada)
metrica_frete = {
    f"Loja{i+1}" if i > 0 else "Loja": (
        max(dados["Frete"]),                # Valor máximo
        statistics.mean(dados["Frete"]),    # Média
        statistics.stdev(dados["Frete"])    # Desvio padrão
    )
    for i, dados in enumerate(lojas)
}

# 2. Ordenação por média de frete (decrescente)
metrica_frete_ordenada = dict(sorted(
    metrica_frete.items(),
    key=lambda x: x[1][1],  # Ordena pela média (posição 1 na tupla)
    reverse=True
))

# 3. Preparação dos dados para visualização
nomes_lojas = list(metrica_frete_ordenada.keys())
valores = np.array(list(metrica_frete_ordenada.values()))
metricas = ['Máximo', 'Média', 'Desvio Padrão']

# Configurações do gráfico
config = {
    'figura': {
        'figsize': (12, 6),
        'dpi': 100,
        'facecolor': '#f5f5f5'
    },
    'barras': {
        'largura': 0.25,
        'cores': ['#4c72b0', '#55a868', '#c44e52']
    }
}

# 4. Construção do gráfico
plt.figure(**config['figura'])
posicoes = np.arange(len(nomes_lojas))

# Plotagem das barras agrupadas
for i, metrica in enumerate(metricas):
    # Posicionamento inteligente das barras
    offset = posicoes + i * config['barras']['largura']

    barras = plt.bar(
        offset,
        valores[:, i],
        width=config['barras']['largura'],
        label=metrica,
        color=config['barras']['cores'][i],
        edgecolor='white'
    )

    # Adição dos valores nas barras
    for bar in barras:
        altura = bar.get_height()
        plt.text(
            bar.get_x() + bar.get_width()/2,
            altura + 0.01 * max(valores[:, i]),  # Posição adaptativa
            f'{altura:.2f}',
            ha='center',
            va='bottom',
            fontsize=9
        )

# Personalização do gráfico
plt.title(
    'Análise Comparativa de Custos de Frete\npor Loja',
    fontsize=14,
    pad=20,
    fontweight='bold'
)
plt.xlabel('Lojas', fontsize=12)
plt.ylabel('Valor (R$)', fontsize=12)
plt.xticks(
    posicoes + config['barras']['largura'],
    nomes_lojas,
    rotation=45,
    ha='right'
)

# Elementos adicionais
plt.grid(axis='y', linestyle=':', alpha=0.6)
plt.legend(
    title='Métricas:',
    frameon=True,
    shadow=True,
    bbox_to_anchor=(1, 1),
    loc='upper left'
)

# Ajuste final
plt.tight_layout()
plt.show()